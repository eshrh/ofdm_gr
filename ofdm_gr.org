#+TITLE: Deep dive into the OFDM implementation in GNURadio
#+AUTHOR: Eshan Ramesh
#+DATE: July 18th 2022

* Introduction
GNURadio (GR) provides the =OFDM Transmitter= and =OFDM Receiver=
blocks to do orthogonal frequency division multiplexing. These blocks
are hierarchical, meaning that they're really composed of other (C++)
blocks internally. Indeed, both of these blocks are written in python
and simply describe connections between blocks. Because of this, there's a
great deal of implementation detail in the source code of these blocks
that is poorly documented in a simple and clear manner. This article
is an in-depth explanation of the OFDM implementation.

I'll shortly be working on updating the GR wiki and block
documentation with these notes, but for now they'll stay here. What I
won't be covering in depth is the mathematical basis for much of OFDM,
instead I write about these ideas mostly on my personal [[https://notes.esrh.me/][wiki]], although
the standard texts in telecom certainly do a better job. I'll try to
include a bare minimum here, and link to my wiki articles or other key
sources when possible. [[https://notes.esrh.me/orthogonal_frequency_division_multiplexing.html][Start here]].

** High level introduction to the OFDM idea
Orthogonal frequency division multiplexing is a multi-carrier scheme
that's fairly widely used today, especially in WiFi and LTE.

This multi-carrier property just means that instead of transmitting a
signal at one frequency (on one "carrier wave"), we transmit on many
sub-carriers spaced apart by a little bit of bandwidth.

The core of the idea that makes OFDM special is the technique by which
it makes these subcarriers independent (or, orthogonal), which boils
down to computing the IFFT of the signal at the reciever and adding a
cyclic prefix in between each set (determined by the size of the FFT)
of data pieces. I go into much more detail about why this leads to
interesting properties in [[https://notes.esrh.me/orthogonal_frequency_division_multiplexing.html][another article]] I wrote about it.

* Transmission
The following is a mostly faithful reconstruction of the transmission
scheme given in =gr-digital-python/digital/ofdm_txrx.py=.
[[./images/ofdm_tx.png]]

For the sake of the narrative, we'll take it step by step and
introduce the parameters to each block as we get there.

** File source
For the purposes of this whole example, let's assume we want to
transmit some number of bits, say 16 of them (we'll see why this
number is convenient shortly).

For simplicity, let's say all these bytes are just the integer 1, so
You might generate a file to be used with this block with a bash call
to like ~printf '\xFF\xFF' > test"~, but pick your poison.

The length on the file source should be set to 2, since it reads data
in bytes.

** Stream to tagged stream
Classic streams in GR are just streams of bytes with no information or
grouping. We however, would like to group the bytes together in a
flexible way (meaning that we should be able to increase the size of a
group).

The technique for doing this is attaching a "tag" every $n$ samples,
here 2 as mentioned. This tag says nothing but the length of the group
following it. Really the reason this is necessary is so that C++
programs can allocate memory for a buffer large enough to do
processing on that group, before recieving the data. See the [[https://wiki.gnuradio.org/index.php/Stream_Tags][GRwiki
article]] on tagged streams. Stream tags are quite flexible, and we'll
see them again for other uses. Fundamentally, tags are just a pair of
key and value, where both are polymorphic-types ([[https://wiki.gnuradio.org/index.php?title=Polymorphic_Types_(PMTs)][PMT's]]).
** Stream CRC32
This block simply adds the CRC32 error-detection code to the end of
the data. The reasons why CRC32 tends to be pretty good for OFDM
bursts, and the implementation of the algorithm are explained pretty
well by [[https://en.wikipedia.org/wiki/Cyclic_redundancy_check][this wikipedia article]].

The CRC32, as the name suggests, adds 32 bits ($\frac{32}{8} = 4$
bytes) to our data, bringing the length up to 6 bytes.

** Header generator
The data coming out of the tagged stream block splits here. We'll talk
about the header generation first.

Let's take some time to talk poorly-named jargon for a second:

+ OFDM frame/burst :: a set of some number (as many as necessary) of
  OFDM symbols and other stuff
+ OFDM symbol :: a set of $n$ (determined by the size of the FFT)
  complex symbols
+ complex symbol :: an atomic piece of encoded data. for more
  information about why you can hold signals as complex numbers, see
  [[https://notes.esrh.me/quadrature_signal.html][my article]] on quadrature signals.

The "other stuff" included in an OFDM frame are 3 extra OFDM symbols,
the header OFDM symbol, and two "sync words" that are known by the
reciever as part of some standard. We'll see the generation of the
sync words and their usage for time and frequency synchronization
later on in the reception section.

The header OFDM symbol (before modulation) contains three pieces of data:
1. 12 bits for the length of the packet (here, 6 (including the 4 extra from the CRC))
2. 12 bits for the header number, which is incremented after every packet (modulo xFFFF)
3. 8 bits of CRC computed from a combination of the above numbers.

We must encode these bits one way or another, but the number of bytes
(and thus complex symbols) used to encode these bits depends on the
[[https://notes.esrh.me/linear_modulation.html][modulation]] scheme used, and in particular, the number of bits we can
encode in a specific complex symbol.

Classically, in the standard, we encode everything in the header with
BPSK, binary phase shift keying, which essentially encodes one bit in
the phase of one complex symbol, and gives all-real complex symbols.

With BPSK, each byte will only have its LSB representing actual
data. With QPSK, which can encode 2 bits per complex symbol, the
lowest 2 bits in the byte represent data, and so on. The reason we
have to do this is because next, we will be mapping bytes to complex
symbols, but it wouldn't do to pack a byte full of data when we can
only encode 1 of the 8 bits into a symbol to transmit.

In sum, at worst (BPSK), we have 32 bytes (although, each byte only
has one bit of data) of header data, but we will send this as one OFDM
symbol on it's own. In IEEE jargon this is either called the header or
the SIGNAL symbol, and in practice also includes information like data
rate (can't just waste 20 bits, can we?).

** Repack bits

Typically the CRC32 block is routed through a "Repack bits" block
before being converted to symbols.

The incoming data is usually a byte array that is packed full of data,
but we want each byte to represent just as many bits as we can encode
into a single complex symbol.

If we're using BPSK, then each byte should only have one bit of
data. The repack bits block takes a $k$ and $l$, and converts bytes
containing $k$ bits of data into bytes containing $l$ bits of
data. Thus for BPSK, we'd use $k = 8, l = 1$, and for QPSK we might
use $k = 8, l = 2$.

At $(8, 1)$, a byte array containing =[FF]= is transformed into =[1 1
1 1 1 1 1 1]= Similarly, A byte containing =[0F]= becomes =[0 0 0 0 1
1 1 1]=, where each of these 0s and 1s aren't bits, but *bytes with
the top 7 bits off*.

** Chunks to Symbols
Here we convert each byte into a complex symbol. This is done via a
symbol table, or a /constellation/. I briefly discuss the ideas behind
constellation encoding [[https://notes.esrh.me/phase_shift_keying.html][here]], but the high level idea is to map each
bit, or sequence of bits, to a "location" on the complex plane, or a
pair of real and complex co-ordinates, so they can be transmitted as a
quadrature signal. This is possible since $\sin$ and $\cos$ form
orthogonal bases for the signal space.

Constellations are typically quite specific. Points on the
constellation should be as far apart as possible, in order to minimize
the ambiguity when decoding any particular recieved complex
symbol. However, the distance of a constellation point from the origin
affects the energy (magnitude of the resulting symbol) required to
transmit, and so this must be considered as well.

Here we use binary-phase-shift-keying for the payload's encoding,
although the IEEE standard suggests QPSK for a higher data
transmission rate. In BPSK, resulting complex symbols are real, and
the real part is 1 if the bit is 1, and -1 if the bit is 0.

In gnuradio, the BPSK constellation points are obtained as:

#+begin_src python
from gnuradio import digital
header_mod = digital.constellation_bpsk()
points = header_mod.points()
#+end_src
** Tagged stream mux
This block combines two streams in order. The output is the first
stream followed by the second stream.

** OFDM carrier allocator
Now, we have a long stream of complex symbols, (80, to be exact), and
we must transform them into vectors of what to load into each
frequency. Assuming that we are using 64 subcarriers (IEEE standard),
we expect to produce a vector of $n$ samples, which are each arrays of
64 complex numbers, where $n$ is the number of OFDM symbols we're
sending in the frame.

Here, we have one OFDM symbol for the header, one symbol for sync word
1, and another symbol for sync word 2, and one symbol for data and the
CRC32 code. The structure of each sync word is given below.

In OFDM, although we get 64 subcarriers to transmit on, payload OFDM
symbols only get 48.

The [[https://notes.esrh.me/ieee802_11.html][IEEE 802.11a]] standard suggests transmitting on subcarriers from
-26 to +26, for a total of 52 subcarriers. That's what we'll use for
now in our example. This subcarrier indexing is relative to some
central carrier frequency at index 0. The frequency spacing between
subcarriers will be determined by the size of the FFT.

The bottom 6 and top 5 subcarriers are meant to be left empty
according to the IEEE standard. This is generally to prevent excessive
out-of-band emission. It's also convenient when applying a low-pass
filter to the signal.

Additionally, the zero-subcarrier is left null. This is again a
measure for hardware devices that have interference at the carrier
frequency, specifically [[https://en.wikipedia.org/wiki/Direct-conversion_receiver][synchrodynes]] which have an oscillator tuned to
the carrier frequency.

Finally, the pilot subcarriers, (-21, -7, 7, 21) contain
receiver-known data as well. These sequences are used for a wide
variety of purposes, and it's protocol dependent. Here, the pilot
sequence is (1, 1, 1, -1), one symbol per pilot tone.

It's important to note that the preamble (combination of the sync
words) don't follow these rules. The sync words transmit
non-pilot sequences on the pilot subcarriers.

The reason why we chose to transmit 2 bytes is now clear. After CRC,
we have 6 bytes, and $6 * 8 = 48$ bits, if you use BPSK to encode one
bit to one complex symbol, this is exactly as many as we can fit into
one OFDM symbol. Using QPSK as the IEEE standard suggests would let
you fit twice as much data.

The operation of the OFDM carrier allocator block is now fairly simple
to explain.

1. Copy each sync word into the output buffer (each are 64 complex
   symbols) straight
2. For each of the header and data symbols (remember, we muxed them)
   1. Copy a symbol to each of the occupied carriers
   2. Fill in the pilot carriers with the pilot sequence
3. Return the size of the vector to ensure it's formatted correctly

Because we have 2 sync words, 1 header, and 1 data symbol, we'll have
4 OFDM symbols in a single vector sample [see below for a
clarification on this] now.

*** Sync words in OFDM synchronization
The idea of "sync words" are fundamental to wireless
communication. The receiver is only able to equalize for environmental
and interference conditions (the "channel"), when there is some data
transmitted that is known to both the transmitter and receiver.

Sync words may also be used for detecting when the packet starts at
all, as well as compensating for a constant (across subcarriers)
frequency offset, the /carrier frequency offset/.

Typically, these sync words have some clever properties that make
doing these easier. I'll outline the generation of each of these sync
words briefly.

**** Sync word 1
Sync word 1 is generally used for timing estimation (i.e when does our
data start), which is sent first since you can only pick up data
following it.

In 1997, Schmidl & Cox proposed using a sync word that had identical
first and second halves. What is actually in these halves isn't so
relevant, but they should have constant transmit energy.

From a property of the discrete fourier transform, the classical way
to produce a time-domain signal that is duplicated around its center
is to take the DFT of a signal that has real-only data on even
frequencies (assuming a symmetric fft frequency ordering scheme
starting from $-k$ and ending at $k-1$ inclusive). To be more
specific, this holds when the signal has hermitian symmetry and the
right parity. In the interest of space, I'm not including the proof
here, but it can be found in 8.6.4 (p. 653) of /Discrete-Time Signal
Processing/ by Oppenheim & Schafer.

We can produce this sync word with:
#+begin_src python
list(map(lambda x: np.sqrt(2) * np.random.choice([-1, 1])
         if (x in oc[0]+[-21, -7, 7, 21] and x % 2 == 0)
         else 0,
         range(-32, 32)))
#+end_src
where ~oc[0]~ is a list of occupied carriers.

**** Sync word 2
Sync word 2 is used for channel estimation and coarse frequency
offset. Computed via

#+begin_src python
list(map(lambda x: np.random.choice([-1, 1])
         if x in oc[0]+[-21, -7, 7, 21]
         else 0,
         range(-32, 32)))
#+end_src

Note that the second sync word indeed has higher magnitudes, and thus
transmit energy, but it will prove to be useful during reception.

*** Streams vs vectors
In GR, streams and vectors are the two main types of data passing
techniques. Streams pass each sample individually, whereas vectors
contain some number of samples in a vector.

In this way, blocks that operate on vectors (notably, the FFT block),
should be thought of as doing a parallel computation.
** FFT
This block simply applies the inverse [[https://notes.esrh.me/fourier_transform.html][discrete fourier transform]] in
parallel (operates on a vector) to each of the 64-length OFDM symbols.

The output will therefore also be 64-length time-domain OFDM symbols,
although the meaning of the word is now slightly different. The
inverse fourier transform is used here, expecting that the resulting
time domain signal will be cyclically prefixed.
** OFDM cyclic prefixer
This block applied a cyclic prefix to each item in the vector input. A
cyclic prefix is simply prefixing a block by some number of
time-domain symbols from the end of a 64-length block.

The cyclic prefix is the core of the OFDM idea, and has deep
implications for equalization at the receiver. I'd recommend my
article on OFDM, or the paper "Wireless multicarrier communications"
by Wang & Giannakis (2000).

The high level idea, skipping a fair bit of linear algebra, is that
adding the cyclic prefix turns the linear convolution of the data with
the channel (since the output of a linearly time invariant channel is
determined via linear convolution) into a circular convolution. As it
would turn out, the matrix that does circular convolution turns out to
be diagonalizable in the Fourier basis, which implies a removal of
inter-symbol interference by pre and post multiplying by the inverse
DFT and DFT matrices, as well as cheap equalization techniques.

As for the implementation of the cyclic prefixer block, I'll only
explain it in a bit of a limited scope. The block has two operating
modes, one meant to be used before the carrier allocator in the stream
domain "packet mode", and the other meant to be used after the FFT, in
so called "freewheeling mode." I'll only cover the second, which is
enabled by not specifying a length tag.

Additionally, the block supports the application of the raised
cosine pulse shaping filter parametrized by a rolloff length, but this
is typically unnecessary and is indeed set to a default of 0.
***
** Output
Quick picture of what you might expect to see at the transmission end
of the OFDM chain.
[[./images/frequency.png]]

We can clearly see the side lobes due to null subcarriers.
* Reception
Here's an expansion of the reciever block, which is significantly more
complicated than the transmitter.
# TODO
** Schmidl & Cox
The first step in decoding an OFDM burst is to figure out when it
starts. This block uses the strategy given by Schmidl & Cox in their
1997 paper "Robust Frequency and Timing Synchronization for OFDM."
There are two things that the algorithm achieves. The first is
determining when the frame starts of course, but the second is coming
up with a fine frequency offset measure that in effect cancels out the
short-term carrier frequency offset, in which the carrier frequency is
slightly off due to a slight, constant time offset in the oscillator.

*** Timing sync
The timing synchronization portion relies on the property of the first
sync word to be symmetric, as in its first half should be exactly
equal to its second half.

We also know how long the whole symbol is, 64 complex
samples. Therefore, we can figure out when we're looking at the sync
word by [[https://notes.esrh.me/autocorrelation.html][autocorrelating]] the incoming signal with a signal that's
delayed backwards in time by 32 samples. Recall that autocorrelation
is really just multiplying with the conjugate, so clearly we'll get
the highest value when the two signals "match up".

The schmidl and cox block is a hierarchical block itself which does
this.
1. Delay the signal by 32 samples, take its complex conjugate
2. Multiply with the non-delayed signal
3. Low-pass-filter to smoothen the data
4. Compute the magnitude squared of each complex symbol
5. Divide by the square of the magnitude squared of the non-delayed
   signal, also low-pass-filtered. This normalizes the correlation
   metric since you're dividing out one part of the original multiplication.
6. Find the plateau of the result of 5.

[[./images/sc.png]]

You can observe a graph showing autocorrelation peaks like the above
by defining the flag SYNC_ADD_DEBUG_OUTPUT in the source file
=ofdm_sync_sc_cfb_impl.cc=, editing the corresponding block =.yml=
file, and recompiling gnuradio. This is handy for fine tuning the
necessary threshold for plateau detection. The graph above is recorded
during a transmission with USRP 2901 SDRs. I believe the smaller peaks
are due to the fact that our payload OFDM symbol is all ones, and is
therefore also close to having identical first and second halves,
except for the pilot symbols.

**** Plateau Detection
Step 6 has some nuance. You will see that the S&C block outputs a
/byte/ on the "trigger" port which is wired to the plateau
detector.

The plateau detector accepts a series of floats, the output will be a
byte array filled with as many zeros as samples are given, and a 1 at
the index at which the plateau was detected.

Plateau detection works by looking for data above a certain
threshold. This threshold must be heuristically determined (i.e trial
and error) based on channel conditions. Once a data point above the
threshold is found, we continue iterating until we find the first data
point below the threshold. If the difference between the indices of
these two points is bigger than one (there wasn't just an outlier),
then we set the index corresponding to the midpoint between the two
points to 1 in the output byte buffer.

I'm not entirely certain why the center of the plateau is chosen
instead of the flank start.
*** Fine frequency offset
The key observation is that the frequency offset we're trying to
eliminate, the carrier frequency offset, will result in accumulated
phase shifts over time. Since the first sync word is identical in the
first and second half, all we need to do is compare the recorded
phases in the first half and the second half.

This is done in much the same way as the timing sync computation.
1. Compute the correlation between the signal and the signal delayed
   by half the length of the OFDM symbol (32 samples)
2. Low-pass filter the result of the correlation, and compute the arg
   (a.k.a arctan, angle or phase)
3. Output the latest arg result from 2 when a peak is detected by the
   plateau detector in the timing sync path.

It is critical to note that the output of this block isn't actually
"frequency offset" as the name suggests, but phase offset instead,
$\hat{\phi}$ in the paper if you're familiar with it.

**** Applying the frequency offset
Actually modifying the signal using the frequency offset metric
computed earlier is not immediately straightforward.

The first issue is that because the plateau detection is done using a
signal delayed by N/2 samples, by the time we've detected the frame,
we must have finished looking at the (undelayed) second half, and
compared it to the (delayed) first half. So, when we actually want to
use the frame, we have to backtrack, by using a signal delayed by the
length of the whole sync word. Recall that the sync word is 64
samples, but there are 16 extra samples from the cyclic
prefix. Therefore, we have to use the signal shifted by 80 samples.

The second issue is that the normalized frequency offset has to be
applied to the signal. In the paper, the authors write (p. 8) that the
frequency must be offset by $\frac{\hat{\phi}}$ by multiplying the
signal with the complex waveform $e^{-j2t\hat{\phi}\frac{1}{T}}$ where
$\phi = \Delta f \pi T$ (eq. 39). Substituting, we get $e^{-j2\pi t
\Delta f}$

Things can get a bit tricky here. In the paper, $T$ refers to the
length of the OFDM symbol in /complex symbols/! The index $t$ doesn't
refer to a time index in say, seconds, but rather indexes the complex
symbols, and goes from $0 \dots T$ which is in fact equal to the size
of the FFT. Similarly, $\Delta f$ does not refer to actual bandwidth
in Hz, but is instead normalized to the spacing of the carriers
themselves.

The frequency mod block computes the waveform $e^{jk\phi}$, where $k$
is the sensitivity parameter. Really, this block performs general frequency
modulation of a signal that varies, but in for this case this
simplification works fine. Solving for $k$, we see that it must be
$\frac{-2}{T}$ in order to match the required waveform.

In summary, all we really need to do is take the phase offset
estimate, produce a waveform that will correct the signal via
frequency modulation, and the multiply that waveform with a
sufficiently delayed version of the signal.
** Header/Payload Demux
The HPD block is a very complex mechanism for parsing burst
transmissions like OFDM. The block acts like a state machine, with the
default state being waiting for the data on the trigger port. An
important distinction when discussing the parameters of this block is
items vs symbols. Items refers to the actual complex samples coming
from the radio. Symbols on the other hand, refers to OFDM symbols
here. Therefore, our items_per_symbol should be fft_len, 64. Ensure
that the block is set to output symbols, because this is what every
OFDM block expects downstream.

*** Trigger state
In the default state, we search the byte array sent to the trigger
port, and find the index (i.e offset) until the first set byte. From
here, switch to the header state.

*** Header state
Header state copies a certain parametrized number of full symbols (64
items) into the header port, and switches to the msg wait port.

Here, we wait for a message to be sent to the message in port. This
state does nothing, and will not be exited until
parse_header_data_msg() is called to set the state to either
HEADER_RX_FAIL or HEADER_RX_SUCCESS.

This method waits for a PMT (polymorphic type) dictionary, where the
key is an interned string corresponding to the length_tag_key and the
value is a long representing how many OFDM symbols are in the current
frame (which recall, is encoded in the header symbol). Alternatively,
you may also just send a single PMT long, in which case this is
interpreted as the length of the payload. A PMT that is parsed in
either way sends us to the success state.

A PMT that is instead PMT_F (the token failure placeholder) sends us
to the failure state. Two extra cases can send us to the failure
state, one in which the payload length is negative, and one in which
the payload length is greater than the half the output buffer. By
default, this means that you are capped at 64 payload symbols per
frame, if your items are indeed complex.

For our purposes in this example, it is entirely possible to write a
block to, on receiving any data, sends a message with value 1, since
we know how many OFDM symbols are in the payload, but in practice the
number of payload symbol varies depending on how much data we need to
transmit.
*** Header RX Success
Transitional state that consumes the header items and any
padding. This is to make the in buffer aligned perfectly with the
payload on the next work iteration.
*** Payload
Simply copy the number of items determined in the header state to the
payload output port. If the output symbols option is toggled, then the
output will be symbols, therefore the payload will be a vector of
length payload_length (here 1), and each element is another array of
64 complex numbers).

** Header chain
** Payload chain
** Constellation decoder
** Repack bits
** Stream CRC32
