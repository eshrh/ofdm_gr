<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-07-22 Fri 16:56 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Deep dive into the OFDM implementation in GNURadio</title>
<meta name="author" content="Eshan Ramesh" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Deep dive into the OFDM implementation in GNURadio</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9bbdf5b">1. Introduction</a>
<ul>
<li><a href="#org107af72">1.1. High level introduction to the OFDM idea</a></li>
</ul>
</li>
<li><a href="#orgd534d24">2. Transmission</a>
<ul>
<li><a href="#orgcde6956">2.1. File source</a></li>
<li><a href="#orgdfd6922">2.2. Stream to tagged stream</a></li>
<li><a href="#org9a945d8">2.3. Stream CRC32</a></li>
<li><a href="#org08877d7">2.4. Header generator</a></li>
<li><a href="#orgb0bd92b">2.5. Repack bits</a></li>
<li><a href="#org85a3ed3">2.6. Chunks to Symbols</a></li>
<li><a href="#orge352322">2.7. Tagged stream mux</a></li>
<li><a href="#org22c0432">2.8. OFDM carrier allocator</a>
<ul>
<li><a href="#org7b12783">2.8.1. Sync words in OFDM synchronization</a></li>
<li><a href="#org8146696">2.8.2. Streams vs vectors</a></li>
</ul>
</li>
<li><a href="#org37ce846">2.9. FFT</a></li>
<li><a href="#orgfb37eb2">2.10. OFDM cyclic prefixer</a></li>
<li><a href="#org4bbbde3">2.11. Output</a></li>
</ul>
</li>
<li><a href="#org665998c">3. Reception</a>
<ul>
<li><a href="#orgd619c73">3.1. Schmidl &amp; Cox</a>
<ul>
<li><a href="#org4a93684">3.1.1. Timing sync</a></li>
<li><a href="#orgc0ed4ea">3.1.2. Fine frequency offset</a></li>
</ul>
</li>
<li><a href="#org5fbd8b6">3.2. Header/Payload Demux</a>
<ul>
<li><a href="#org7b3f2a9">3.2.1. Trigger state</a></li>
<li><a href="#org829e8cc">3.2.2. Header state</a></li>
<li><a href="#org95bf638">3.2.3. Header RX Success</a></li>
<li><a href="#orgea1fbf7">3.2.4. Payload</a></li>
</ul>
</li>
<li><a href="#org1f03c2e">3.3. Header chain: FFT</a></li>
<li><a href="#orgc9ac627">3.4. Header chain: OFDM Channel estimation</a>
<ul>
<li><a href="#org20cea33">3.4.1. Carrier offset</a></li>
<li><a href="#org4b52b44">3.4.2. Channel taps</a></li>
</ul>
</li>
<li><a href="#org5b78b22">3.5. Header chain: Frame equalizer</a>
<ul>
<li><a href="#orgadbb821">3.5.1. Offset correction</a></li>
<li><a href="#org07631f5">3.5.2. Phase correction due to offset</a></li>
<li><a href="#org253c444">3.5.3. Equalization</a></li>
</ul>
</li>
<li><a href="#orgeee43ab">3.6. Header chain: OFDM Serializer</a></li>
<li><a href="#orge1e0a60">3.7. Header chain: Constellation decoder</a></li>
<li><a href="#org4068299">3.8. Header chain: Packet header parser</a></li>
<li><a href="#org8179870">3.9. Payload chain</a></li>
<li><a href="#orged78e38">3.10. Repack bits</a></li>
<li><a href="#org6f61c05">3.11. Stream CRC32</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org9bbdf5b" class="outline-2">
<h2 id="org9bbdf5b"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
GNURadio (GR) provides the <code>OFDM Transmitter</code> and <code>OFDM Receiver</code>
blocks to do orthogonal frequency division multiplexing. These blocks
are hierarchical, meaning that they're really composed of other (C++)
blocks internally. Indeed, both of these blocks are written in python
and simply describe connections between blocks. Because of this, there's a
great deal of implementation detail in the source code of these blocks
that is poorly documented in a simple and clear manner. This article
is an in-depth explanation of the OFDM implementation.
</p>

<p>
I'll shortly be working on updating the GR wiki and block
documentation with these notes, but for now they'll stay here. What I
won't be covering in depth is the mathematical basis for much of OFDM,
instead I write about these ideas mostly on my personal <a href="https://notes.esrh.me/">wiki</a>, although
the standard texts in telecom certainly do a better job. I'll try to
include a bare minimum here, and link to my wiki articles or other key
sources when possible. <a href="https://notes.esrh.me/orthogonal_frequency_division_multiplexing.html">Start here</a>.
</p>
</div>

<div id="outline-container-org107af72" class="outline-3">
<h3 id="org107af72"><span class="section-number-3">1.1.</span> High level introduction to the OFDM idea</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Orthogonal frequency division multiplexing is a multi-carrier scheme
that's fairly widely used today, especially in WiFi and LTE.
</p>

<p>
This multi-carrier property just means that instead of transmitting a
signal at one frequency (on one "carrier wave"), we transmit on many
sub-carriers spaced apart by a little bit of bandwidth.
</p>

<p>
The core of the idea that makes OFDM special is the technique by which
it makes these subcarriers independent (or, orthogonal), which boils
down to computing the IFFT of the signal at the reciever and adding a
cyclic prefix in between each set (determined by the size of the FFT)
of data pieces. I go into much more detail about why this leads to
interesting properties in <a href="https://notes.esrh.me/orthogonal_frequency_division_multiplexing.html">another article</a> I wrote about
</p>
</div>
</div>
</div>
<div id="outline-container-orgd534d24" class="outline-2">
<h2 id="orgd534d24"><span class="section-number-2">2.</span> Transmission</h2>
<div class="outline-text-2" id="text-2">
<p>
The following is a mostly faithful reconstruction of the transmission
scheme given in <code>gr-digital-python/digital/ofdm_txrx.py</code>.
</p>

<div id="orgb108e65" class="figure">
<p><img src="./images/ofdm_tx.png" alt="ofdm_tx.png" width="100%" />
</p>
</div>

<p>
For the sake of the narrative, we'll take it step by step and
introduce the parameters to each block as we get there.
</p>
</div>

<div id="outline-container-orgcde6956" class="outline-3">
<h3 id="orgcde6956"><span class="section-number-3">2.1.</span> File source</h3>
<div class="outline-text-3" id="text-2-1">
<p>
For the purposes of this whole example that we'll follow through the
chain, let's assume we want to transmit some number of bits, say 16 of
them (we'll see why this number is convenient shortly).
</p>

<p>
For simplicity, let's say all these bytes are just 1 bits, so
You might generate a file to be used with this block with a bash call
to like <code>printf '\xFF\xFF' &gt; test</code>, but pick your poison.
</p>

<p>
Set the length to 2, since we want 2 bytes.
</p>
</div>
</div>
<div id="outline-container-orgdfd6922" class="outline-3">
<h3 id="orgdfd6922"><span class="section-number-3">2.2.</span> Stream to tagged stream</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Classic streams in GR are just streams of bytes with no information or
grouping. We however, would like to group the bytes together in a
flexible way (meaning that we should be able to increase the size of a
group).
</p>

<p>
The technique for doing this is attaching a "tag" every \(n\)
samples,. This tag says nothing but the length of the group following
it. Really the reason this is necessary is so that C++ programs can
allocate memory for a buffer large enough to do processing on that
group, before recieving the data. See the <a href="https://wiki.gnuradio.org/index.php/Stream_Tags">GRwiki article</a> on tagged
streams. Stream tags are quite flexible, and we'll see them again for
other uses. Fundamentally, tags are just a pair of key and value,
where both are polymorphic-types (<a href="https://wiki.gnuradio.org/index.php?title=Polymorphic_Types_(PMTs)">PMT's</a>).
</p>

<p>
For our example, since we want to transmit 2 bytes, we'll set the
length to 2.
</p>
</div>
</div>

<div id="outline-container-org9a945d8" class="outline-3">
<h3 id="org9a945d8"><span class="section-number-3">2.3.</span> Stream CRC32</h3>
<div class="outline-text-3" id="text-2-3">
<p>
This block simply adds the CRC32 error-detection code to the end of
the data. The reasons why CRC32 tends to be pretty good for OFDM
bursts, and the implementation of the algorithm are explained pretty
well by <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">this wikipedia article</a>.
</p>

<p>
The CRC32, as the name suggests, adds 32 bits (\(\frac{32}{8} = 4\)
bytes) to our data, bringing the length up to 6 bytes.
</p>
</div>
</div>

<div id="outline-container-org08877d7" class="outline-3">
<h3 id="org08877d7"><span class="section-number-3">2.4.</span> Header generator</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The data coming out of the tagged stream block splits here. We'll talk
about the header generation first.
</p>

<p>
Let's take some time to talk poorly-named jargon for a second:
</p>

<dl class="org-dl">
<dt>OFDM frame/burst</dt><dd>a set of some number (as many as necessary) of
OFDM symbols and other stuff</dd>
<dt>OFDM symbol</dt><dd>a set of \(n\) (determined by the size of the FFT)
complex symbols</dd>
<dt>complex symbol</dt><dd>an atomic piece of encoded data. for more
information about why you can hold signals as complex numbers, see
<a href="https://notes.esrh.me/quadrature_signal.html">my article</a> on quadrature signals.</dd>
</dl>

<p>
The "other stuff" included in an OFDM frame are 3 extra OFDM symbols,
the header OFDM symbol, and two "sync words" that are known by the
reciever as part of some standard. We'll see the generation of the
sync words and their usage for time and frequency synchronization
later on in the reception section.
</p>

<p>
The header OFDM symbol (before modulation) contains three pieces of data:
</p>
<ol class="org-ol">
<li>12 bits for the length of the packet (here, 6 (including the 4 extra from the CRC))</li>
<li>12 bits for the header number, which is incremented after every packet (modulo xFFFF)</li>
<li>8 bits of CRC computed from a combination of the above numbers.</li>
</ol>

<p>
We must encode these bits one way or another, but the number of bytes
(and thus complex symbols) used to encode these bits depends on the
<a href="https://notes.esrh.me/linear_modulation.html">modulation</a> scheme used, and in particular, the number of bits we can
encode in a specific complex symbol.
</p>

<p>
Classically, in the standard, we encode everything in the header with
BPSK, binary phase shift keying, which essentially encodes one bit in
the phase of one complex symbol, and gives all-real complex symbols.
</p>

<p>
With BPSK, each byte will only have its LSB representing actual
data. With QPSK, which can encode 2 bits per complex symbol, the
lowest 2 bits in the byte represent data, and so on. The reason we
have to do this is because next, we will be mapping bytes to complex
symbols, but it wouldn't do to pack a byte full of data when we can
only encode 1 of the 8 bits into a symbol to transmit.
</p>

<p>
In sum, at worst (BPSK), we have 32 bytes (although, each byte only
has one bit of data) of header data, but we will send this as one OFDM
symbol on it's own. In IEEE jargon this is either called the header or
the SIGNAL symbol, and in practice also includes information like data
rate (can't just waste 20 bits, can we?).
</p>

<p>
A particularly sharp reader might notice that we encode the packet
length as 6, even though the real packet length will be 6 * 8 = 48
complex symbols. This is fine, because the factor of 8 is compensated
on the receiver side in the OFDM serializer block, which we'll cover
shortly.
</p>
</div>
</div>

<div id="outline-container-orgb0bd92b" class="outline-3">
<h3 id="orgb0bd92b"><span class="section-number-3">2.5.</span> Repack bits</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Typically the CRC32 block is routed through a "Repack bits" block
before being converted to symbols.
</p>

<p>
The incoming data is usually a byte array that is packed full of data,
but we want each byte to represent just as many bits as we can encode
into a single complex symbol.
</p>

<p>
If we're using BPSK, then each byte should only have one bit of
data. The repack bits block takes a \(k\) and \(l\), and converts bytes
containing \(k\) bits of data into bytes containing \(l\) bits of
data. Thus for BPSK, we'd use \(k = 8, l = 1\), and for QPSK we might
use \(k = 8, l = 2\).
</p>

<p>
At \((8, 1)\), a byte array containing <code>[FF]</code> is transformed into <code>[1 1
1 1 1 1 1 1]</code> Similarly, A byte containing <code>[0F]</code> becomes <code>[0 0 0 0 1
1 1 1]</code>, where each of these 0s and 1s aren't bits, but <b>bytes with
the top 7 bits off</b>.
</p>
</div>
</div>

<div id="outline-container-org85a3ed3" class="outline-3">
<h3 id="org85a3ed3"><span class="section-number-3">2.6.</span> Chunks to Symbols</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Here we convert each byte into a complex symbol. This is done via a
symbol table, or a <i>constellation</i>. I briefly discuss the ideas behind
constellation encoding <a href="https://notes.esrh.me/phase_shift_keying.html">here</a>, but the high level idea is to map each
bit, or sequence of bits, to a "location" on the complex plane, or a
pair of real and complex co-ordinates, so they can be transmitted as a
quadrature signal. This is possible since \(\sin\) and \(\cos\) form
orthogonal bases for the signal space.
</p>

<p>
Constellations are typically quite specific. Points on the
constellation should be as far apart as possible, in order to minimize
the ambiguity when decoding any particular recieved complex
symbol. However, the distance of a constellation point from the origin
affects the energy (magnitude of the resulting symbol) required to
transmit, and so this must be considered as well.
</p>

<p>
Here we use binary-phase-shift-keying for the payload's encoding,
although the IEEE standard suggests QPSK for a higher data
transmission rate. In BPSK, resulting complex symbols are real, and
the real part is 1 if the bit is 1, and -1 if the bit is 0.
</p>

<p>
In gnuradio, the BPSK constellation points are obtained as:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5317ac;">from</span> gnuradio <span style="color: #5317ac;">import</span> digital
<span style="color: #00538b;">header_mod</span> = digital.constellation_bpsk()
<span style="color: #00538b;">points</span> = header_mod.points()
</pre>
</div>
</div>
</div>
<div id="outline-container-orge352322" class="outline-3">
<h3 id="orge352322"><span class="section-number-3">2.7.</span> Tagged stream mux</h3>
<div class="outline-text-3" id="text-2-7">
<p>
This block combines two streams in order. The output is the first
stream followed by the second stream.
</p>
</div>
</div>

<div id="outline-container-org22c0432" class="outline-3">
<h3 id="org22c0432"><span class="section-number-3">2.8.</span> OFDM carrier allocator</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Now, we have a long stream of complex symbols, (80, to be exact), and
we must transform them into vectors of what to load into each
frequency. Assuming that we are using 64 subcarriers (IEEE standard),
we expect to produce a vector of \(n\) samples, which are each arrays of
64 complex numbers, where \(n\) is the number of OFDM symbols we're
sending in the frame.
</p>

<p>
Here, we have one OFDM symbol for the header, one symbol for sync word
1, and another symbol for sync word 2, and one symbol for data and the
CRC32 code. The structure of each sync word is given below.
</p>

<p>
In OFDM, although we get 64 subcarriers to transmit on, payload OFDM
symbols only get 48.
</p>

<p>
The <a href="https://notes.esrh.me/ieee802_11.html">IEEE 802.11a</a> standard suggests transmitting on subcarriers from
-26 to +26, for a total of 52 subcarriers. That's what we'll use for
now in our example. This subcarrier indexing is relative to some
central carrier frequency at index 0. The frequency spacing between
subcarriers will be determined by the size of the FFT.
</p>

<p>
The bottom 6 and top 5 subcarriers are meant to be left empty
according to the IEEE standard. This is generally to prevent excessive
out-of-band emission. It's also convenient when applying a low-pass
filter to the signal.
</p>

<p>
Additionally, the zero-subcarrier is left null. This is again a
measure for hardware devices that have interference at the carrier
frequency, specifically <a href="https://en.wikipedia.org/wiki/Direct-conversion_receiver">synchrodynes</a> which have an oscillator tuned to
the carrier frequency.
</p>

<p>
Finally, the pilot subcarriers, (-21, -7, 7, 21) contain
receiver-known data as well. These sequences are used for a wide
variety of purposes, and it's protocol dependent. Here, the pilot
sequence is (1, 1, 1, -1), one symbol per pilot tone.
</p>

<p>
It's important to note that the preamble (combination of the sync
words) don't follow these rules. The sync words transmit
non-pilot sequences on the pilot subcarriers.
</p>

<p>
The reason why we chose to transmit 2 bytes is now clear. After CRC,
we have 6 bytes, and \(6 * 8 = 48\) bits, if you use BPSK to encode one
bit to one complex symbol, this is exactly as many as we can fit into
one OFDM symbol. Using QPSK as the IEEE standard suggests would let
you fit twice as much data.
</p>

<p>
The operation of the OFDM carrier allocator block is now fairly simple
to explain.
</p>

<ol class="org-ol">
<li>Copy each sync word into the output buffer (each are 64 complex
symbols) straight</li>
<li>For each of the header and data symbols (remember, we muxed them)
<ol class="org-ol">
<li>Copy a symbol to each of the occupied carriers</li>
<li>Fill in the pilot carriers with the pilot sequence</li>
</ol></li>
<li>Return the size of the vector to ensure it's formatted correctly</li>
</ol>

<p>
Because we have 2 sync words, 1 header, and 1 data symbol, we'll have
4 OFDM symbols in a single vector sample [see below for a
clarification on this] now.
</p>
</div>

<div id="outline-container-org7b12783" class="outline-4">
<h4 id="org7b12783"><span class="section-number-4">2.8.1.</span> Sync words in OFDM synchronization</h4>
<div class="outline-text-4" id="text-2-8-1">
<p>
The idea of "sync words" are fundamental to wireless
communication. The receiver is only able to equalize for environmental
and interference conditions (the "channel"), when there is some data
transmitted that is known to both the transmitter and receiver.
</p>

<p>
Sync words may also be used for detecting when the packet starts at
all, as well as compensating for a constant (across subcarriers)
frequency offset, the <i>carrier frequency offset</i>.
</p>

<p>
Typically, these sync words have some clever properties that make
doing these easier. I'll outline the generation of each of these sync
words briefly.
</p>
</div>

<ol class="org-ol">
<li><a id="org6a1961b"></a>Sync word 1<br />
<div class="outline-text-5" id="text-2-8-1-1">
<p>
Sync word 1 is generally used for timing estimation (i.e when does our
data start), which is sent first since you can only pick up data
following it.
</p>

<p>
In 1997, Schmidl &amp; Cox proposed using a sync word that had identical
first and second halves. What is actually in these halves isn't so
relevant, but they should have constant transmit energy.
</p>

<p>
From a property of the discrete fourier transform, the classical way
to produce a time-domain signal that is duplicated around its center
is to take the DFT of a signal that has real-only data on even
frequencies (assuming a symmetric fft frequency ordering scheme
starting from \(-k\) and ending at \(k-1\) inclusive). To be more
specific, this holds when the signal has hermitian symmetry and the
right parity. In the interest of space, I'm not including the proof
here, but it can be found in 8.6.4 (p. 653) of <i>Discrete-Time Signal
Processing</i> by Oppenheim &amp; Schafer.
</p>

<p>
We can produce this sync word with:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8f0075;">list</span>(<span style="color: #8f0075;">map</span>(<span style="color: #5317ac;">lambda</span> x: np.sqrt(2) * np.random.choice([-1, 1])
         <span style="color: #5317ac;">if</span> (x <span style="color: #5317ac;">in</span> oc[0]+[-21, -7, 7, 21] <span style="color: #5317ac;">and</span> x % 2 == 0)
         <span style="color: #5317ac;">else</span> 0,
         <span style="color: #8f0075;">range</span>(-32, 32)))
</pre>
</div>
<p>
where <code>oc[0]</code> is a list of occupied carriers.
</p>
</div>
</li>

<li><a id="orge37041e"></a>Sync word 2<br />
<div class="outline-text-5" id="text-2-8-1-2">
<p>
Sync word 2 is used for channel estimation and coarse frequency
offset. Computed via
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8f0075;">list</span>(<span style="color: #8f0075;">map</span>(<span style="color: #5317ac;">lambda</span> x: np.random.choice([-1, 1])
         <span style="color: #5317ac;">if</span> x <span style="color: #5317ac;">in</span> oc[0]+[-21, -7, 7, 21]
         <span style="color: #5317ac;">else</span> 0,
         <span style="color: #8f0075;">range</span>(-32, 32)))
</pre>
</div>

<p>
Note that the second sync word indeed has higher magnitudes, and thus
transmit energy, but it will prove to be useful during reception.
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org8146696" class="outline-4">
<h4 id="org8146696"><span class="section-number-4">2.8.2.</span> Streams vs vectors</h4>
<div class="outline-text-4" id="text-2-8-2">
<p>
In GR, streams and vectors are the two main types of data passing
techniques. Streams pass each sample individually, whereas vectors
contain some number of samples in a vector.
</p>

<p>
In this way, blocks that operate on vectors (notably, the FFT block),
should be thought of as doing a parallel computation.
</p>
</div>
</div>
</div>
<div id="outline-container-org37ce846" class="outline-3">
<h3 id="org37ce846"><span class="section-number-3">2.9.</span> FFT</h3>
<div class="outline-text-3" id="text-2-9">
<p>
This block simply applies the inverse <a href="https://notes.esrh.me/fourier_transform.html">discrete fourier transform</a> in
parallel (operates on a vector) to each of the 64-length OFDM symbols.
</p>

<p>
The output will therefore also be 64-length time-domain OFDM symbols,
although the meaning of the word is now slightly different. The
inverse fourier transform is used here, expecting that the resulting
time domain signal will be cyclically prefixed.
</p>
</div>
</div>
<div id="outline-container-orgfb37eb2" class="outline-3">
<h3 id="orgfb37eb2"><span class="section-number-3">2.10.</span> OFDM cyclic prefixer</h3>
<div class="outline-text-3" id="text-2-10">
<p>
This block applied a cyclic prefix to each item in the vector input. A
cyclic prefix is simply prefixing a block by some number of
time-domain symbols from the end of a 64-length block.
</p>

<p>
The cyclic prefix is the core of the OFDM idea, and has deep
implications for equalization at the receiver. I'd recommend my
article on OFDM, or the paper "Wireless multicarrier communications"
by Wang &amp; Giannakis (2000).
</p>

<p>
The high level idea, skipping a fair bit of linear algebra, is that
adding the cyclic prefix turns the linear convolution of the data with
the channel (since the output of a linearly time invariant channel is
determined via linear convolution) into a circular convolution. As it
would turn out, the matrix that does circular convolution turns out to
be diagonalizable in the Fourier basis, which implies a removal of
inter-symbol interference by pre and post multiplying by the inverse
DFT and DFT matrices, as well as cheap equalization techniques.
</p>

<p>
As for the implementation of the cyclic prefixer block, I'll only
explain it in a bit of a limited scope. The block has two operating
modes, one meant to be used before the carrier allocator in the stream
domain "packet mode", and the other meant to be used after the FFT, in
so called "freewheeling mode." I'll only cover the second, which is
enabled by not specifying a length tag.
</p>

<p>
Additionally, the block supports the application of the raised
cosine pulse shaping filter parametrized by a rolloff length, but this
is typically unnecessary and is indeed set to a default of 0.
<b>*</b>
</p>
</div>
</div>
<div id="outline-container-org4bbbde3" class="outline-3">
<h3 id="org4bbbde3"><span class="section-number-3">2.11.</span> Output</h3>
<div class="outline-text-3" id="text-2-11">
<p>
Quick picture of what you might expect to see at the transmission end
of the OFDM chain.
</p>


<div id="orgc65e38b" class="figure">
<p><img src="./images/frequency.png" alt="frequency.png" width="100%" />
</p>
</div>

<p>
We can clearly see the side lobes due to null subcarriers.
</p>
</div>
</div>
</div>
<div id="outline-container-org665998c" class="outline-2">
<h2 id="org665998c"><span class="section-number-2">3.</span> Reception</h2>
<div class="outline-text-2" id="text-3">
<p>
Here's an expansion of the reciever block, which is significantly more
complicated than the transmitter.
</p>


<div id="orgcbf997b" class="figure">
<p><img src="./images/ofdm_rx.png" alt="ofdm_rx.png" width="100%" />
</p>
</div>
</div>
<div id="outline-container-orgd619c73" class="outline-3">
<h3 id="orgd619c73"><span class="section-number-3">3.1.</span> Schmidl &amp; Cox</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The first step in decoding an OFDM burst is to figure out when it
starts. This block uses the strategy given by Schmidl &amp; Cox in their
1997 paper "Robust Frequency and Timing Synchronization for OFDM."
There are two things that the algorithm achieves. The first is
determining when the frame starts of course, but the second is coming
up with a fine frequency offset measure that in effect cancels out the
short-term carrier frequency offset, in which the carrier frequency is
slightly off due to a slight, constant time offset in the oscillator.
</p>
</div>

<div id="outline-container-org4a93684" class="outline-4">
<h4 id="org4a93684"><span class="section-number-4">3.1.1.</span> Timing sync</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
The timing synchronization portion relies on the property of the first
sync word to be symmetric, as in its first half should be exactly
equal to its second half.
</p>

<p>
We also know how long the whole symbol is, 64 complex
samples. Therefore, we can figure out when we're looking at the sync
word by <a href="https://notes.esrh.me/autocorrelation.html">autocorrelating</a> the incoming signal with a signal that's
delayed backwards in time by 32 samples. Recall that autocorrelation
is really just multiplying with the conjugate, so clearly we'll get
the highest value when the two signals "match up".
</p>

<p>
The schmidl and cox block is a hierarchical block itself which does
this.
</p>
<ol class="org-ol">
<li>Delay the signal by 32 samples, take its complex conjugate</li>
<li>Multiply with the non-delayed signal</li>
<li>Low-pass-filter to smoothen the data</li>
<li>Compute the magnitude squared of each complex symbol</li>
<li>Divide by the square of the magnitude squared of the non-delayed
signal, also low-pass-filtered. This normalizes the correlation
metric since you're dividing out one part of the original multiplication.</li>
<li>Find the plateau of the result of 5.</li>
</ol>


<div id="org3365813" class="figure">
<p><img src="./images/sc.png" alt="sc.png" width="100%" />
</p>
</div>

<p>
You can observe a graph showing autocorrelation peaks like the above
by defining the flag SYNC<sub>ADD</sub><sub>DEBUG</sub><sub>OUTPUT</sub> in the source file
<code>ofdm_sync_sc_cfb_impl.cc</code>, editing the corresponding block <code>.yml</code>
file, and recompiling gnuradio. This is handy for fine tuning the
necessary threshold for plateau detection. The graph above is recorded
during a transmission with USRP 2901 SDRs. I believe the smaller peaks
are due to the fact that our payload OFDM symbol is all ones, and is
therefore also close to having identical first and second halves,
except for the pilot symbols.
</p>
</div>

<ol class="org-ol">
<li><a id="org6d7bda1"></a>Plateau Detection<br />
<div class="outline-text-5" id="text-3-1-1-1">
<p>
Step 6 has some nuance. You will see that the S&amp;C block outputs a
<i>byte</i> on the "trigger" port which is wired to the plateau
detector.
</p>

<p>
The plateau detector accepts a series of floats, the output will be a
byte array filled with as many zeros as samples are given, and a 1 at
the index at which the plateau was detected.
</p>

<p>
Plateau detection works by looking for data above a certain
threshold. This threshold must be heuristically determined (i.e trial
and error) based on channel conditions. Once a data point above the
threshold is found, we continue iterating until we find the first data
point below the threshold. If the difference between the indices of
these two points is bigger than one (there wasn't just an outlier),
then we set the index corresponding to the midpoint between the two
points to 1 in the output byte buffer.
</p>

<p>
I'm not entirely certain why the center of the plateau is chosen
instead of the flank start.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgc0ed4ea" class="outline-4">
<h4 id="orgc0ed4ea"><span class="section-number-4">3.1.2.</span> Fine frequency offset</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
The key observation is that the frequency offset we're trying to
eliminate, the carrier frequency offset, will result in accumulated
phase shifts over time. Since the first sync word is identical in the
first and second half, all we need to do is compare the recorded
phases in the first half and the second half.
</p>

<p>
This is done in much the same way as the timing sync computation.
</p>
<ol class="org-ol">
<li>Compute the correlation between the signal and the signal delayed
by half the length of the OFDM symbol (32 samples)</li>
<li>Low-pass filter the result of the correlation, and compute the arg
(a.k.a arctan, angle or phase)</li>
<li>Output the latest arg result from 2 when a peak is detected by the
plateau detector in the timing sync path.</li>
</ol>

<p>
It is critical to note that the output of this block isn't actually
"frequency offset" as the name suggests, but phase offset instead,
\(\hat{\phi}\) in the paper if you're familiar with it.
</p>
</div>

<ol class="org-ol">
<li><a id="orgbe3ffe7"></a>Applying the frequency offset<br />
<div class="outline-text-5" id="text-3-1-2-1">
<p>
Actually modifying the signal using the frequency offset metric
computed earlier is not immediately straightforward.
</p>

<p>
The first issue is that because the plateau detection is done using a
signal delayed by N/2 samples, by the time we've detected the frame,
we must have finished looking at the (undelayed) second half, and
compared it to the (delayed) first half. So, when we actually want to
use the frame, we have to backtrack, by using a signal delayed by the
length of the whole sync word. Recall that the sync word is 64
samples, but there are 16 extra samples from the cyclic
prefix. Therefore, we have to use the signal shifted by 80 samples.
</p>

<p>
The second issue is that the normalized frequency offset has to be
applied to the signal. In the paper, the authors write (p. 8) that the
frequency must be offset by \(\frac{\hat{\phi}}\) by multiplying the
signal with the complex waveform \(e^{-j2t\hat{\phi}\frac{1}{T}}\) where
\(\phi = \Delta f \pi T\) (eq. 39). Substituting, we get \(e^{-j2\pi t
\Delta f}\)
</p>

<p>
Things can get a bit tricky here. In the paper, \(T\) refers to the
length of the OFDM symbol in <i>complex symbols</i>! The index \(t\) doesn't
refer to a time index in say, seconds, but rather indexes the complex
symbols, and goes from \(0 \dots T\) which is in fact equal to the size
of the FFT. Similarly, \(\Delta f\) does not refer to actual bandwidth
in Hz, but is instead normalized to the spacing of the carriers
themselves.
</p>

<p>
The frequency mod block computes the waveform \(e^{jk\phi}\), where \(k\)
is the sensitivity parameter. Really, this block performs general frequency
modulation of a signal that varies, but in for this case this
simplification works fine. Solving for \(k\), we see that it must be
\(\frac{-2}{T}\) in order to match the required waveform.
</p>

<p>
In summary, all we really need to do is take the phase offset
estimate, produce a waveform that will correct the signal via
frequency modulation, and the multiply that waveform with a
sufficiently delayed version of the signal.
</p>

<p>
We have to be a little careful here as well. Delaying a signal by 80
samples has the effect of prepending 80 zeros to the front of the
data. With 4 total OFDM symbols, that's 320 + 80 = 400 items. The
Schmidl &amp; Cox block however, receives a signal of length 320, and so
the frequency mod sinusoid is also of length 320. Multiplying the two
in GR, the longer signal will get truncated from the front, which
means that you will lose a data payload symbol, <i>not good!</i>
</p>

<p>
This isn't a real problem if you repeat your frames over and over
again, or if you use a real SDR that is always collecting samples, but
can be hard to debug in a pure, oneshot simulation. The solution is
the mux the input tx stream with an extra 80 items of noise or
constant at the end of the signal data.
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org5fbd8b6" class="outline-3">
<h3 id="org5fbd8b6"><span class="section-number-3">3.2.</span> Header/Payload Demux</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The HPD block is a very complex mechanism for parsing burst
transmissions like OFDM. The block acts like a state machine, with the
default state being waiting for the data on the trigger port. An
important distinction when discussing the parameters of this block is
items vs symbols. Items refers to the actual complex samples coming
from the radio. Symbols on the other hand, refers to OFDM symbols
here. Therefore, our items<sub>per</sub><sub>symbol</sub> should be fft<sub>len</sub>, 64. Ensure
that the block is set to output symbols, because this is what every
OFDM block expects downstream.
</p>
</div>

<div id="outline-container-org7b3f2a9" class="outline-4">
<h4 id="org7b3f2a9"><span class="section-number-4">3.2.1.</span> Trigger state</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
In the default state, we search the byte array sent to the trigger
port, and find the index (i.e offset) until the first set byte. From
here, switch to the header state.
</p>
</div>
</div>

<div id="outline-container-org829e8cc" class="outline-4">
<h4 id="org829e8cc"><span class="section-number-4">3.2.2.</span> Header state</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
Header state copies a certain parametrized number of full symbols (64
items) into the header port, and switches to the msg wait port.
</p>

<p>
Here, we wait for a message to be sent to the message in port. This
state does nothing, and will not be exited until
parse<sub>header</sub><sub>data</sub><sub>msg</sub>() is called to set the state to either
HEADER<sub>RX</sub><sub>FAIL</sub> or HEADER<sub>RX</sub><sub>SUCCESS</sub>.
</p>

<p>
This method waits for a PMT (polymorphic type) dictionary, where the
key is an interned string corresponding to the length<sub>tag</sub><sub>key</sub> and the
value is a long representing how many OFDM symbols are in the current
frame (which recall, is encoded in the header symbol). Alternatively,
you may also just send a single PMT long, in which case this is
interpreted as the length of the payload. A PMT that is parsed in
either way sends us to the success state.
</p>

<p>
A PMT that is instead PMT<sub>F</sub> (the token failure placeholder) sends us
to the failure state. Two extra cases can send us to the failure
state, one in which the payload length is negative, and one in which
the payload length is greater than the half the output buffer. By
default, this means that you are capped at 64 payload symbols per
frame, if your items are indeed complex.
</p>

<p>
For our purposes in this example, it is entirely possible to write a
block to, on receiving any data, sends a message with value 1, since
we know how many OFDM symbols are in the payload, but in practice the
number of payload symbol varies depending on how much data we need to
transmit.
</p>
</div>
</div>
<div id="outline-container-org95bf638" class="outline-4">
<h4 id="org95bf638"><span class="section-number-4">3.2.3.</span> Header RX Success</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Transitional state that consumes the header items and any
padding. This is to make the in buffer aligned perfectly with the
payload on the next work iteration.
</p>
</div>
</div>
<div id="outline-container-orgea1fbf7" class="outline-4">
<h4 id="orgea1fbf7"><span class="section-number-4">3.2.4.</span> Payload</h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
Simply copy the number of items determined in the header state to the
payload output port. If the output symbols option is toggled, then the
output will be symbols, therefore the payload will be a vector of
length payload<sub>length</sub> (here 1), and each element is another array of
64 complex numbers).
</p>

<p>
It's super important to realize, especially in simulation, that the
payload state will only trigger when there actually enough samples as
we're expecting (given the frame length from the message).
</p>
</div>
</div>
</div>
<div id="outline-container-org1f03c2e" class="outline-3">
<h3 id="org1f03c2e"><span class="section-number-3">3.3.</span> Header chain: FFT</h3>
<div class="outline-text-3" id="text-3-3">
<p>
We'll now discuss the "header chain", or the path from the header out port
of the HPD, to the message in port of the same demux block.
</p>

<p>
Currently, our 64-length vector of symbols (currently 3 in the
example, 2 syncs and 1 header) is still in the time domain. However,
they were encoded in the frequency domain, so we convert from time to
frequency with a forward FFT block.
</p>
</div>
</div>
<div id="outline-container-orgc9ac627" class="outline-3">
<h3 id="orgc9ac627"><span class="section-number-3">3.4.</span> Header chain: OFDM Channel estimation</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Here, we use the two sync words in order to compute the coarse carrier
offset and "channel taps" (the frequency response of the channel
across subcarriers). The channel taps specifically are critical to
know because that's how we equalize the signal to get our data out.
</p>

<p>
The channel taps are already corrected by the carrier offset.
</p>

<p>
The output vector will be missing both sync words, so only the header
is left. The channel estimation done results in a 64-length complex
vector, which is added to the vector as a tag, with key
"ofdm<sub>sync</sub><sub>carr</sub><sub>taps</sub>" and the carrier offset is added to the vector as
a tag with key "ofdm<sub>sync</sub><sub>carr</sub><sub>offset</sub>" and is a long.
</p>
</div>

<div id="outline-container-org20cea33" class="outline-4">
<h4 id="org20cea33"><span class="section-number-4">3.4.1.</span> Carrier offset</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
Carrier offset is computed in one of two ways, depending on how many
sync words are supplied.
</p>
</div>
<ol class="org-ol">
<li><a id="orgf7fb8bb"></a>2 sync word case<br />
<div class="outline-text-5" id="text-3-4-1-1">
<p>
Computation follows the same procedure from the schmidl and cox block.
We iterate through some range of possible carrier offsets, compute the
\(B_g\) metric (eq 41), and find the \(g\) that maximizes it iteratively.
</p>
</div>
</li>
<li><a id="orge701bab"></a>1 sync word case<br />
<div class="outline-text-5" id="text-3-4-1-2">
<p>
In this case, the block will fill a new, artificial kind of sync word
by computing the differences between every item and the item two
samples ahead of it. Of course, this means there are two fewer (62)
items in the new word, so there are 2 zeros left behind at the end.
</p>

<p>
Next, we do a very similar correlation procedure between the original
word and the artificial one. First iterate through \(g\) for possible
carrier offsets, and find the \(g\) that gives the maximum sum of products
between the $j$th item of the known sync word and the $j + g$th item
of the artificial one.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org4b52b44" class="outline-4">
<h4 id="org4b52b44"><span class="section-number-4">3.4.2.</span> Channel taps</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
To compute channel taps, we'll use the second sync word if it exists,
otherwise just use the first one.
</p>

<p>
GR does channel estimation using a very simple technique, in which
every item received in the sync word is just divided by the known item
at that index.
</p>

<p>
We must offset the taps using the carrier offset computed
earlier. This is simply done by only computing the channel taps
starting at the offset frequency if positive, or ending \(g\) items
short of the end of symbols if negative. While doing the division, we
compare every $i$th received element with the $i - g$th element, where
\(g\) is the offset in carriers.
</p>

<p>
In the one-sync word case, where we're forced to use sync word 1, we
have to deal with the fact that there is only data on the even
frequencies. Because everything else is 0s, the channel taps
(received/reference) will also be 0s on the odd frequencies. To
interpolate, GR uses the naive strategy of setting every odd frequency
to the even frequency immediately behind it.
</p>

<p>
In the source file for ofdm<sub>chanest</sub><sub>vcvc</sub>, there's a TODO left for
implementing red noise thresholding.
</p>
</div>
</div>
</div>
<div id="outline-container-org5b78b22" class="outline-3">
<h3 id="org5b78b22"><span class="section-number-3">3.5.</span> Header chain: Frame equalizer</h3>
<div class="outline-text-3" id="text-3-5">
<p>
This block equalizes an OFDM frame (a sequence of OFDM symbols) using
the tags produced by the chanest block earlier. To be a bit more
accurate, the block itself doesn't do the equalization, but uses an
equalizer object that the user passes in.
</p>

<p>
One extra tag is added to the vector output, containing the number of
symbols in the frame.
</p>

<p>
Before using the equalizer object, a few things are done:
</p>
</div>
<div id="outline-container-orgadbb821" class="outline-4">
<h4 id="orgadbb821"><span class="section-number-4">3.5.1.</span> Offset correction</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>If the offset \(g\) is negative, then set \(g\) zeros in the beginning
of the output, and copy the whole header shifted forward by \(g\)
items.</li>
<li>If the offset is positive, we need to shift back. Set the last \(g\)
items to be zeros, and then copy the header starting at the offset
straight into the output buffer, dropping \(g\) items at the end to
avoid writing into the zeros.</li>
</ul>
</div>
</div>
<div id="outline-container-org07631f5" class="outline-4">
<h4 id="org07631f5"><span class="section-number-4">3.5.2.</span> Phase correction due to offset</h4>
<div class="outline-text-4" id="text-3-5-2">
<p>
The carrier offset (an offset in frequency) will also result in a
phase offset. This is also corrected. For each OFDM symbol, every item
is multiplied by a factor of \(\exp{j-2\pi g (i + 1) \frac{N_{gi}}/{N}}\)
where \(g\) is the offset, \(N_{gi}\) is the length of the guard interval,
\(N\) is the fft size, and \(i\) is the index of the current OFDM symbol.
</p>

<p>
Looking at this phase correction, the point to notice is the the phase
correction for each OFDM symbol changes over time, and indeed
accumulates until it wraps around \(2\pi\). Second, the speed at which
the phase correction changes depends on the size of the carrier
offset. If the carrier offset in 1, then the phase correction factor
wraps around every 4 symbols, but if 2, then it wraps around every
other symbol.
</p>
</div>
</div>

<div id="outline-container-org253c444" class="outline-4">
<h4 id="org253c444"><span class="section-number-4">3.5.3.</span> Equalization</h4>
<div class="outline-text-4" id="text-3-5-3">
<p>
There are two variants of equalizers implemented in GR at the time of
writing, static and simpledfe. We'll discuss simpledfe (simple
Decision Feedback Equalizer) here.
</p>

<p>
There are essentially two parts to how the equalizer works. The first
is the pilot-based channel modification, and the second is the
constellation mapping.
</p>

<p>
For each symbol \(i\) and for each subcarrier \(k\) in each symbol, if it is a
pilot carrier then we update the channel state for \(k\) to be
</p>

\begin{equation}
\alpha * H[k] + (1-\alpha) * \frac{s_{i, k}}{p_j}
\end{equation}

<p>
Where \(H\) is the frequency response of the channel, \(\alpha = 0.1\) is
a constant, \(p_j\) is the pilot symbol corresponding to the $k$th
index, and \(s_{i,k}\) is the received symbol.
</p>

<p>
Note that this modified channel is written back to the same tag that
the channel taps were found on.
</p>

<p>
If the subcarrier is not a pilot subcarrier, then we update the
channel in a similar way.
</p>

<p>
First, let the equalized symbol just be \(\frac{s_{i, k}}{H_k}\). Next,
we use the constellation mapper to essentially "snap" the complex item
to a complex item that we know, in this case either -1 or +1.
</p>

<p>
Now that we know what this symbol really was (the decision), we can
use this feedback to update our channel slightly, via the same
equation above, just using the snapped complex number instead of the
pilot symbol.
</p>

<p>
If soft output is enabled (not by default), then the non-snapped
output is outputted, otherwise the snapped, perfectly constellation
aligned output is used.
</p>

<p>
Before propagation, the new output is also corrected for phase shift.
</p>
</div>
</div>
</div>
<div id="outline-container-orgeee43ab" class="outline-3">
<h3 id="orgeee43ab"><span class="section-number-3">3.6.</span> Header chain: OFDM Serializer</h3>
<div class="outline-text-3" id="text-3-6">
<p>
This block undoes the carrier allocation, and pulls out the data from
each successive symbol's data subcarriers and strings them together
into a stream.
</p>

<p>
There are some easy footguns to make here related to tags, so again
I'll try to be very specific.
</p>

<p>
This block takes in two different length tags.
</p>
<ul class="org-ul">
<li>"length tag key" is the tag that is <i>used</i>. The previous block
writes a tag</li>
<li>"packet length tag key" (packet<sub>len</sub><sub>tag</sub><sub>key</sub>) and this refers to the
<i>stream length</i> of the output stream. This block is a subclass of
the tagged stream block, which adds a tag to denote groups just like
it was done in the tx section. This tag only matters for the output!</li>
</ul>

<p>
The packet length tag key coming out is distinct from the packet
length tag key used in the transmitter. This is critical because the
same header<sub>formatter</sub> object is used in the transmitter and receiver
sections.
</p>

<p>
If the standard length tag key (i.e the frame length) is not provided,
then we simply recalculate the frame length.
</p>

<p>
The rest of the operation is straightforward. For every symbol in the
frame, pull out the complex items on each data subcarriers, making
sure to respect carrier offset.
</p>

<p>
Specifically, the $i$th output item corresponds to the $s<sub>i, k +
g</sub>$th input item.
</p>
</div>
</div>
<div id="outline-container-orge1e0a60" class="outline-3">
<h3 id="orge1e0a60"><span class="section-number-3">3.7.</span> Header chain: Constellation decoder</h3>
<div class="outline-text-3" id="text-3-7">
<p>
We now have complex packets, and must decode them back to bits (1-sig
bit bytes). This is done with the constellation decoder.
</p>

<p>
The simplest way to explain its operation is that we just calculate
the distance between the incoming complex item, and the constellation
points. We pick the closest one, and then output the byte
corresponding to that point. Notice though, that all the points will
already be perfectly snapped to one of the constellation points (so
the distance to the closest point will be zero) if we're using the
simple DFE described earlier.
</p>
</div>
</div>
<div id="outline-container-org4068299" class="outline-3">
<h3 id="org4068299"><span class="section-number-3">3.8.</span> Header chain: Packet header parser</h3>
<div class="outline-text-3" id="text-3-8">
<p>
Does the opposite of the header generator.
</p>

<p>
The goal is to recover the length of the payload and the number of the
packet.
</p>

<p>
This is done by just picking out the data from the 32 bits, packet
length first, then header number, and finally the CRC. Then, we
compute the CRC and ensure that the data recovered is correct. If
its not correct, this results in an error.
</p>

<p>
If it is, then we put the payload length and the header number onto
the stream as tags, and then send a message containing every tag as a
PMT dictionary. These tags are not all necessary, but the payload
length one is essential for the HPD to continue operating.
</p>
</div>
</div>
<div id="outline-container-org8179870" class="outline-3">
<h3 id="org8179870"><span class="section-number-3">3.9.</span> Payload chain</h3>
<div class="outline-text-3" id="text-3-9">
<p>
The payload chain operates in pratically the exact same was the header
chain, so I won't duplicate that writing.
</p>

<p>
The only difference to speak of is that the channel estimation block
is not used. The reason is that the tag containing the channel's
frequency response is preserved through the header/paylod
demux. Therefore, we can just use the data on the tag.
</p>
</div>
</div>
<div id="outline-container-orged78e38" class="outline-3">
<h3 id="orged78e38"><span class="section-number-3">3.10.</span> Repack bits</h3>
<div class="outline-text-3" id="text-3-10">
<p>
Every byte received only contains one bit of information, as a result
of our chosen modulation scheme. We should repack these bits into full
bytes.
</p>
</div>
</div>
<div id="outline-container-org6f61c05" class="outline-3">
<h3 id="org6f61c05"><span class="section-number-3">3.11.</span> Stream CRC32</h3>
<div class="outline-text-3" id="text-3-11">
<p>
Every packet sent contained 4 bytes of CRC32. The CRC32 block checks
it to ensure that the packet was recovered correctly.
</p>

<p>
If it was, we're done!
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: July 18th 2022</p>
<p class="author">Author: Eshan Ramesh</p>
<p class="date">Created: 2022-07-22 Fri 16:56</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>